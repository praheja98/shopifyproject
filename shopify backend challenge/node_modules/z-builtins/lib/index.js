// Generated by CoffeeScript 1.7.1
(function() {
  var exportArbitraryMethod, exportMethod, exportMutatorMethod, func, global, isArray, logging, method, methods, name, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4,
    __slice = [].slice;

  methods = require('./methods');

  logging = require('./logging');

  isArray = Array.isArray || function(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  };

  global = (function() {
    return this;
  })();

  exportMethod = function(method) {
    return exports[method] = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.value[method].apply(this.value, args);
    };
  };

  exportMutatorMethod = function(method) {
    return exports[method] = function() {
      var args, newValue;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (!Array.isArray(this.value)) {
        throw new Error("Must be an array");
      }
      newValue = this.value.slice(0);
      newValue[method].apply(newValue, args);
      return newValue;
    };
  };

  exportArbitraryMethod = function(name, method) {
    return exports[name] = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return method.apply(null, [this.value].concat(__slice.call(args)));
    };
  };

  for (name in logging) {
    func = logging[name];
    exports[name] = func;
  }

  _ref = methods.plain;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    method = _ref[_i];
    exportMethod(method);
  }

  _ref1 = methods.mutators;
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    method = _ref1[_j];
    exportMutatorMethod(method);
  }

  _ref2 = methods.globals;
  for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
    method = _ref2[_k];
    exportArbitraryMethod(method, global[method]);
  }

  _ref3 = methods.methods;
  for (name in _ref3) {
    method = _ref3[name];
    exportArbitraryMethod(name, method);
  }

  _ref4 = methods.maths;
  for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
    method = _ref4[_l];
    exportArbitraryMethod(method, Math[method]);
  }

  exports.length = function() {
    if (typeof this.value !== 'string' && !isArray(this.value)) {
      throw new Error('Function "length" can only be called on strings and arrays');
    }
    return this.value.length;
  };

  exports.get = function(property) {
    return this.value[property];
  };

  exports.toStr = function() {
    return this.value.toString();
  };

  exports["if"] = function(f1, f2) {
    if (this.value) {
      return f1();
    } else if (f2) {
      return f2();
    }
  };

}).call(this);
