// Generated by CoffeeScript 1.7.1
(function() {
  var Promise, init, isArray, isPrimitive, keys, makeZ, object, objectCreate, pairs, proc, resolveAll, resolveCompletely, tools, values,
    __slice = [].slice;

  tools = require('./tools');

  Promise = require('es6-promise').Promise;

  pairs = tools.pairs, keys = tools.keys, values = tools.values, object = tools.object, resolveAll = tools.resolveAll, isPrimitive = tools.isPrimitive, isArray = tools.isArray, objectCreate = tools.objectCreate, proc = tools.proc;

  resolveCompletely = function(unresolved, depth) {
    return resolveAll([unresolved]).then(function(_arg) {
      var resolved, unresolvedValues;
      resolved = _arg[0];
      if (depth <= 0 || (resolved == null) || isPrimitive(resolved)) {
        return resolved;
      }
      if (isArray(resolved)) {
        return resolveAll(resolved.map(function(x) {
          return resolveCompletely(x, depth - 1);
        }));
      }
      unresolvedValues = resolveAll(values(resolved).map(function(x) {
        return resolveCompletely(x, depth - 1);
      }));
      return unresolvedValues.then(function(resolvedValues) {
        return object(keys(resolved), resolvedValues);
      });
    });
  };

  init = function(defaultConf) {
    var Z, depth, mixedIn, mixinObj, updateMixinObj;
    mixedIn = {};
    mixinObj = {};
    depth = (defaultConf != null ? defaultConf.depth : void 0) != null ? defaultConf != null ? defaultConf.depth : void 0 : 1000000;
    updateMixinObj = function() {
      return pairs(mixedIn).forEach(function(_arg) {
        var func, name;
        name = _arg[0], func = _arg[1];
        return mixinObj[name] = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return this.then(function(resolved) {
            return resolveCompletely(args, depth).then(function(args) {
              return func.apply({
                value: resolved
              }, args);
            });
          });
        };
      });
    };
    Z = function(obj) {
      var key, overrideLayer, resolvedObject, resultingPromise, value;
      resolvedObject = resolveCompletely(obj, depth);
      overrideLayer = objectCreate(resolvedObject);
      resultingPromise = objectCreate(overrideLayer);
      overrideLayer.then = function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return Z(resolvedObject.then.apply(resolvedObject, args));
      };
      for (key in mixinObj) {
        value = mixinObj[key];
        resultingPromise[key] = value;
      }
      return resultingPromise;
    };
    Z.mixin = proc(function(hash) {
      pairs(hash).forEach(function(_arg) {
        var func, name, oldOne;
        name = _arg[0], func = _arg[1];
        oldOne = mixedIn[name];
        return mixedIn[name] = function() {
          var context;
          context = {
            value: this.value
          };
          if (oldOne) {
            context.base = oldOne;
          }
          return func.apply(context, arguments);
        };
      });
      return updateMixinObj();
    });
    Z.mixinAsync = proc(function(hash) {
      pairs(hash).forEach(function(_arg) {
        var func, name, oldOne;
        name = _arg[0], func = _arg[1];
        oldOne = mixedIn[name];
        return mixedIn[name] = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return new Promise((function(_this) {
            return function(resolve, reject) {
              var context, e;
              context = {
                value: _this.value
              };
              if (oldOne) {
                context.base = oldOne;
              }
              context.done = function(err, value) {
                if (err) {
                  return reject(err);
                }
                return resolve(value);
              };
              try {
                return func.apply(context, args);
              } catch (_error) {
                e = _error;
                return reject(e);
              }
            };
          })(this));
        };
      });
      return updateMixinObj();
    });
    Z.bindSync = function(func, context) {
      return function() {
        var unresolvedArgs;
        unresolvedArgs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return Z(unresolvedArgs).then((function(_this) {
          return function(args) {
            return func.apply(context != null ? context : _this, args);
          };
        })(this));
      };
    };
    Z.bindAsync = function(func, context) {
      return function() {
        var ctx, unresolvedArgs;
        unresolvedArgs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        ctx = context != null ? context : this;
        return Z(unresolvedArgs).then(function(args) {
          return new Promise(function(resolve, reject) {
            var ex;
            args.push(function() {
              var err, result;
              err = arguments[0], result = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
              if (err != null) {
                return reject(err);
              } else if (result.length === 1) {
                return resolve(result[0]);
              } else {
                return resolve(result);
              }
            });
            try {
              return func.apply(ctx, args);
            } catch (_error) {
              ex = _error;
              return reject(ex);
            }
          });
        });
      };
    };
    return Z;
  };

  makeZ = function() {
    var Z;
    Z = init();
    Z.init = init;
    return Z;
  };

  if (typeof window !== 'undefined' && typeof window.require === 'undefined') {
    window.Z = makeZ();
  }

  if (typeof module !== 'undefined') {
    module.exports = makeZ();
  }

}).call(this);
